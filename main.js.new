/**
 * Campus Room Scheduler - Main Process
 * Modern Electron application with secure IPC and proper architecture
 * 
 * @version 2.0.0
 * @author Campus Scheduler Team
 */

'use strict';

const { app, BrowserWindow, Menu, ipcMain, dialog } = require('electron');
const path = require('path');
const url = require('url');

// Import custom modules
const DB = require('./src/db');
const AuthService = require('./src/auth');
const RecurrenceService = require('./src/recurrence');
const NotificationService = require('./src/notify');
const { exportICal } = require('./src/exportCalendar');
const { buildMenuTemplate, buildDeveloperMenu } = require('./src/MenuBuilder');

// ========== Configuration ==========

const isDev = process.env.NODE_ENV !== 'production';

// Enable live reload in development
if (isDev) {
  try {
    require('electron-reload')(__dirname, {
      electron: path.join(__dirname, 'node_modules', '.bin', 'electron'),
      hardResetMethod: 'exit',
    });
  } catch (err) {
    console.log('Electron reload not available');
  }
}

// ========== Data Store & Services ==========

const db = new DB();
const authService = new AuthService(db);
const recurrenceService = new RecurrenceService(db);
const notificationService = new NotificationService();

// ========== Window References ==========

let mainWindow = null;
let scheduleWindow = null;
let addWindow = null;
let calendarWindow = null;

// ========== Window Creation Functions ==========

/**
 * Create the main application window
 */
function createMainWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    title: 'Campus Room Scheduler',
    backgroundColor: '#ffffff',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      enableRemoteModule: false,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  mainWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'mainWindow.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  // Open DevTools in development
  if (isDev) {
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on('closed', () => {
    mainWindow = null;
    // On macOS, keep app running even when windows are closed
    if (process.platform !== 'darwin') {
      app.quit();
    }
  });

  // Handle navigation (security)
  mainWindow.webContents.on('will-navigate', (event, navigationUrl) => {
    const parsedUrl = new URL(navigationUrl);
    if (parsedUrl.origin !== 'file://') {
      event.preventDefault();
      console.warn('Navigation blocked:', navigationUrl);
    }
  });
}

/**
 * Create the schedule window
 */
function createScheduleWindow() {
  if (scheduleWindow) {
    scheduleWindow.focus();
    return;
  }

  scheduleWindow = new BrowserWindow({
    width: 1000,
    height: 700,
    title: 'Schedule Management',
    parent: mainWindow,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  scheduleWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'Schedule.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  // Send initial data when ready
  scheduleWindow.webContents.on('did-finish-load', () => {
    const names = dataStore.getNames();
    scheduleWindow.webContents.send('names', names);
  });

  scheduleWindow.on('closed', () => {
    scheduleWindow = null;
  });
}

/**
 * Create the add item window
 */
function createAddWindow() {
  if (addWindow) {
    addWindow.focus();
    return;
  }

  addWindow = new BrowserWindow({
    width: 400,
    height: 350,
    title: 'Add Schedule Item',
    parent: mainWindow || scheduleWindow,
    modal: true,
    resizable: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  addWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'addWindow.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  // Remove menu bar from modal window
  addWindow.setMenuBarVisibility(false);

  addWindow.on('closed', () => {
    addWindow = null;
  });
}

/**
 * Create the calendar window
 */
function createCalendarWindow() {
  if (calendarWindow) {
    calendarWindow.focus();
    return;
  }

  calendarWindow = new BrowserWindow({
    width: 900,
    height: 950,
    title: 'Calendar View',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  calendarWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'calendar', 'Calendar.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  calendarWindow.on('closed', () => {
    calendarWindow = null;
  });
}

/**
 * Create the rooms management window
 */
function createRoomsWindow() {
  const roomsWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    title: 'Room Management',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  roomsWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'rooms.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  if (isDev) {
    roomsWindow.webContents.openDevTools();
  }
}

/**
 * Create the kiosk window
 */
function createKioskWindow() {
  const kioskWindow = new BrowserWindow({
    width: 1024,
    height: 768,
    title: 'Kiosk - Campus Scheduler',
    fullscreen: true,
    kiosk: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  kioskWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'kiosk.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  // Disable menu in kiosk mode
  kioskWindow.setMenu(null);
}

/**
 * Create the bookings window
 */
function createBookingsWindow() {
  const bookingsWindow = new BrowserWindow({
    width: 1400,
    height: 900,
    title: 'Room Bookings',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  bookingsWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'bookings.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  if (isDev) {
    bookingsWindow.webContents.openDevTools();
  }
}

// ========== IPC Handlers ==========

/**
 * Handle add item request
 */
ipcMain.on('item:add', (event, item) => {
  if (!item || typeof item !== 'string' || item.trim() === '') {
    console.warn('Invalid item received:', item);
    return;
  }

  try {
    // Add to data store
    dataStore.addName(item.trim());

    // Notify all windows
    const windows = [mainWindow, scheduleWindow];
    windows.forEach(win => {
      if (win && !win.isDestroyed()) {
        win.webContents.send('item:add', item);
      }
    });

    // Close add window
    if (addWindow && !addWindow.isDestroyed()) {
      addWindow.close();
    }
  } catch (error) {
    console.error('Error adding item:', error);
    dialog.showErrorBox('Error', 'Failed to add item: ' + error.message);
  }
});

/**
 * Handle clear items request
 */
ipcMain.on('item:clear', () => {
  try {
    dataStore.clearNames();
    
    const windows = [mainWindow, scheduleWindow];
    windows.forEach(win => {
      if (win && !win.isDestroyed()) {
        win.webContents.send('item:clear');
      }
    });
  } catch (error) {
    console.error('Error clearing items:', error);
  }
});

/**
 * Handle window open requests
 */
ipcMain.on('open-schedule', () => createScheduleWindow());
ipcMain.on('open-calendar', () => createCalendarWindow());
ipcMain.on('open-time-sorter', () => {
  // TODO: Implement time sorter window
  console.log('Time sorter requested');
});
ipcMain.on('open-rooms', () => createRoomsWindow());
ipcMain.on('open-bookings', () => createBookingsWindow());
ipcMain.on('open-kiosk', () => createKioskWindow());

// ========== Room IPC Handlers ==========

/**
 * Get all rooms
 */
ipcMain.handle('rooms:get', async () => {
  try {
    return db.getRooms();
  } catch (error) {
    console.error('Error getting rooms:', error);
    throw error;
  }
});

/**
 * Add a new room
 */
ipcMain.handle('rooms:add', async (event, room) => {
  try {
    db.addRoom(room);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('rooms:updated', db.getRooms());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error adding room:', error);
    throw error;
  }
});

/**
 * Update a room
 */
ipcMain.handle('rooms:update', async (event, id, updates) => {
  try {
    db.updateRoom(id, updates);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('rooms:updated', db.getRooms());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error updating room:', error);
    throw error;
  }
});

/**
 * Delete a room
 */
ipcMain.handle('rooms:delete', async (event, id) => {
  try {
    db.deleteRoom(id);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('rooms:updated', db.getRooms());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error deleting room:', error);
    throw error;
  }
});

/**
 * Get room by ID
 */
ipcMain.handle('rooms:getById', async (event, id) => {
  try {
    return db.getRoomById(id);
  } catch (error) {
    console.error('Error getting room by ID:', error);
    throw error;
  }
});

// ========== Booking IPC Handlers ==========

/**
 * Get all bookings
 */
ipcMain.handle('bookings:get', async () => {
  try {
    return db.getBookings();
  } catch (error) {
    console.error('Error getting bookings:', error);
    throw error;
  }
});

/**
 * Add a new booking
 */
ipcMain.handle('bookings:add', async (event, booking) => {
  try {
    // Check availability first
    const available = db.isRoomAvailable(
      booking.roomId,
      booking.startTime,
      booking.endTime
    );
    
    if (!available) {
      throw new Error('Room is not available for the selected time slot');
    }
    
    const id = db.addBooking(booking);
    
    // Send confirmation email if configured
    if (booking.email) {
      try {
        const room = db.getRoomById(booking.roomId);
        await notificationService.sendBookingConfirmation({
          to: booking.email,
          subject: 'Booking Confirmation',
          text: `Your booking for ${room?.name || 'room'} on ${new Date(booking.startTime).toLocaleString()} has been confirmed.`
        });
      } catch (emailErr) {
        console.warn('Email notification failed:', emailErr.message);
      }
    }
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('bookings:updated', db.getBookings());
      }
    });
    
    return { success: true, id };
  } catch (error) {
    console.error('Error adding booking:', error);
    throw error;
  }
});

/**
 * Update a booking
 */
ipcMain.handle('bookings:update', async (event, id, updates) => {
  try {
    // If updating times, check availability
    if (updates.startTime || updates.endTime) {
      const booking = db.getBookingById(id);
      if (!booking) {
        throw new Error('Booking not found');
      }
      
      const startTime = updates.startTime || booking.startTime;
      const endTime = updates.endTime || booking.endTime;
      
      // Check availability using DB method
      const available = db.isRoomAvailable(booking.roomId, startTime, endTime, id);
      
      if (!available) {
        throw new Error('Time slot conflicts with another booking');
      }
    }
    
    db.updateBooking(id, updates);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('bookings:updated', db.getBookings());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error updating booking:', error);
    throw error;
  }
});

/**
 * Delete a booking
 */
ipcMain.handle('bookings:delete', async (event, id) => {
  try {
    db.deleteBooking(id);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('bookings:updated', db.getBookings());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error deleting booking:', error);
    throw error;
  }
});

/**
 * Get booking by ID
 */
ipcMain.handle('bookings:getById', async (event, id) => {
  try {
    return db.getBookingById(id);
  } catch (error) {
    console.error('Error getting booking by ID:', error);
    throw error;
  }
});

/**
 * Get bookings by room
 */
ipcMain.handle('bookings:getByRoom', async (event, roomId) => {
  try {
    return db.getBookingsByRoom(roomId);
  } catch (error) {
    console.error('Error getting bookings by room:', error);
    throw error;
  }
});

/**
 * Check room availability
 */
ipcMain.handle('bookings:checkAvailability', async (event, roomId, startTime, endTime, excludeBookingId) => {
  try {
    return db.isRoomAvailable(roomId, startTime, endTime, excludeBookingId);
  } catch (error) {
    console.error('Error checking availability:', error);
    throw error;
  }
});

// ========== Auth IPC Handlers ==========

/**
 * Create new user
 */
ipcMain.handle('auth:createUser', async (event, { username, password, role }) => {
  try {
    const user = await authService.createUser({ username, password, role });
    return { success: true, user };
  } catch (error) {
    console.error('Error creating user:', error);
    throw error;
  }
});

/**
 * Login
 */
ipcMain.handle('auth:login', async (event, { username, password }) => {
  try {
    const session = await authService.login(username, password);
    return { success: true, session };
  } catch (error) {
    console.error('Login error:', error);
    throw error;
  }
});

/**
 * Validate session token
 */
ipcMain.handle('auth:validate', async (event, token) => {
  try {
    const session = authService.validate(token);
    return session ? { valid: true, session } : { valid: false };
  } catch (error) {
    console.error('Validation error:', error);
    throw error;
  }
});

/**
 * Logout
 */
ipcMain.handle('auth:logout', async (event, token) => {
  try {
    authService.logout(token);
    return { success: true };
  } catch (error) {
    console.error('Logout error:', error);
    throw error;
  }
});

// ========== Recurrence IPC Handlers ==========

/**
 * Expand recurrence rule
 */
ipcMain.handle('recurrence:expand', async (event, { rule, windowStart, windowEnd, dtstart, duration }) => {
  try {
    const occurrences = recurrenceService.expand(rule, {
      windowStart: windowStart ? new Date(windowStart) : undefined,
      windowEnd: windowEnd ? new Date(windowEnd) : undefined,
      dtstart: dtstart ? new Date(dtstart) : undefined,
      duration
    });
    return { success: true, occurrences };
  } catch (error) {
    console.error('Recurrence expansion error:', error);
    throw error;
  }
});

/**
 * Create daily recurrence rule
 */
ipcMain.handle('recurrence:createDaily', async (event, { dtstart, interval, until, count }) => {
  try {
    const rule = recurrenceService.createDaily(
      new Date(dtstart),
      { interval, until: until ? new Date(until) : undefined, count }
    );
    return { success: true, rule };
  } catch (error) {
    console.error('Create daily recurrence error:', error);
    throw error;
  }
});

/**
 * Create weekly recurrence rule
 */
ipcMain.handle('recurrence:createWeekly', async (event, { dtstart, byweekday, interval, until, count }) => {
  try {
    const rule = recurrenceService.createWeekly(
      new Date(dtstart),
      { byweekday, interval, until: until ? new Date(until) : undefined, count }
    );
    return { success: true, rule };
  } catch (error) {
    console.error('Create weekly recurrence error:', error);
    throw error;
  }
});

/**
 * Create monthly recurrence rule
 */
ipcMain.handle('recurrence:createMonthly', async (event, { dtstart, bymonthday, interval, until, count }) => {
  try {
    const rule = recurrenceService.createMonthly(
      new Date(dtstart),
      { bymonthday, interval, until: until ? new Date(until) : undefined, count }
    );
    return { success: true, rule };
  } catch (error) {
    console.error('Create monthly recurrence error:', error);
    throw error;
  }
});

// ========== Export IPC Handlers ==========

/**
 * Export calendar as iCal
 */
ipcMain.handle('export:ical', async () => {
  try {
    const icalString = exportICal();
    return { success: true, data: icalString };
  } catch (error) {
    console.error('Export error:', error);
    throw error;
  }
});

/**
 * Export all data (backup)
 */
ipcMain.handle('export:backup', async () => {
  try {
    const data = db.exportAll();
    return { success: true, data };
  } catch (error) {
    console.error('Backup error:', error);
    throw error;
  }
});

/**
 * Import data (restore)
 */
ipcMain.handle('import:restore', async (event, data) => {
  try {
    db.importAll(data);
    
    // Notify all windows
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('rooms:updated', db.getRooms());
        win.webContents.send('bookings:updated', db.getBookings());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Restore error:', error);
    throw error;
  }
});

// ========== Menu Setup ==========

/**
 * Build and set application menu
 */
function setupMenu() {
  const menuTemplate = buildMenuTemplate({
    onAddItem: () => createAddWindow(),
    onClearItems: () => {
      if (scheduleWindow && !scheduleWindow.isDestroyed()) {
        scheduleWindow.webContents.send('item:clear');
      }
    },
    onOpenSchedule: () => createScheduleWindow(),
    onOpenCalendar: () => createCalendarWindow(),
    onOpenTimeSorter: () => {
      console.log('Time sorter not yet implemented');
    },
  });

  // Add developer menu in development mode
  if (isDev) {
    menuTemplate.push(buildDeveloperMenu());
  }

  const menu = Menu.buildFromTemplate(menuTemplate);
  Menu.setApplicationMenu(menu);
}

// ========== App Lifecycle ==========

/**
 * App ready handler
 */
app.whenReady().then(() => {
  createMainWindow();
  setupMenu();

  // On macOS, re-create window when dock icon is clicked
  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createMainWindow();
    }
  });
});

/**
 * Quit when all windows are closed (except on macOS)
 */
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

/**
 * Before quit - cleanup
 */
app.on('before-quit', () => {
  // Perform any cleanup here
  console.log('Application closing...');
});

/**
 * Handle uncaught exceptions
 */
process.on('uncaughtException', (error) => {
  console.error('Uncaught exception:', error);
  
  dialog.showErrorBox(
    'Application Error',
    'An unexpected error occurred. The application may need to restart.\n\n' + error.message
  );
});

// ========== Security ==========

/**
 * Disable navigation to external URLs
 */
app.on('web-contents-created', (event, contents) => {
  contents.on('will-navigate', (event, navigationUrl) => {
    const parsedUrl = new URL(navigationUrl);
    
    // Only allow file:// protocol
    if (parsedUrl.protocol !== 'file:') {
      event.preventDefault();
      console.warn('Blocked navigation to:', navigationUrl);
    }
  });

  // Prevent new window creation
  contents.setWindowOpenHandler(({ url }) => {
    console.warn('Blocked window open:', url);
    return { action: 'deny' };
  });
});

// Export for testing
module.exports = {
  createMainWindow,
  createScheduleWindow,
  createAddWindow,
  createCalendarWindow,
};
