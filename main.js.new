/**
 * Campus Room Scheduler - Main Process
 * Modern Electron application with secure IPC and proper architecture
 * 
 * @version 2.0.0
 * @author Campus Scheduler Team
 */

'use strict';

const { app, BrowserWindow, Menu, ipcMain, dialog } = require('electron');
const path = require('path');
const url = require('url');

// Import custom modules
const DataStore = require('./src/DataStore');
const { buildMenuTemplate, buildDeveloperMenu } = require('./src/MenuBuilder');

// ========== Configuration ==========

const isDev = process.env.NODE_ENV !== 'production';

// Enable live reload in development
if (isDev) {
  try {
    require('electron-reload')(__dirname, {
      electron: path.join(__dirname, 'node_modules', '.bin', 'electron'),
      hardResetMethod: 'exit',
    });
  } catch (err) {
    console.log('Electron reload not available');
  }
}

// ========== Data Store ==========

const dataStore = new DataStore({ name: 'campus-scheduler' });

// ========== Window References ==========

let mainWindow = null;
let scheduleWindow = null;
let addWindow = null;
let calendarWindow = null;

// ========== Window Creation Functions ==========

/**
 * Create the main application window
 */
function createMainWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    title: 'Campus Room Scheduler',
    backgroundColor: '#ffffff',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      enableRemoteModule: false,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  mainWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'mainWindow.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  // Open DevTools in development
  if (isDev) {
    mainWindow.webContents.openDevTools();
  }

  mainWindow.on('closed', () => {
    mainWindow = null;
    // On macOS, keep app running even when windows are closed
    if (process.platform !== 'darwin') {
      app.quit();
    }
  });

  // Handle navigation (security)
  mainWindow.webContents.on('will-navigate', (event, navigationUrl) => {
    const parsedUrl = new URL(navigationUrl);
    if (parsedUrl.origin !== 'file://') {
      event.preventDefault();
      console.warn('Navigation blocked:', navigationUrl);
    }
  });
}

/**
 * Create the schedule window
 */
function createScheduleWindow() {
  if (scheduleWindow) {
    scheduleWindow.focus();
    return;
  }

  scheduleWindow = new BrowserWindow({
    width: 1000,
    height: 700,
    title: 'Schedule Management',
    parent: mainWindow,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  scheduleWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'Schedule.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  // Send initial data when ready
  scheduleWindow.webContents.on('did-finish-load', () => {
    const names = dataStore.getNames();
    scheduleWindow.webContents.send('names', names);
  });

  scheduleWindow.on('closed', () => {
    scheduleWindow = null;
  });
}

/**
 * Create the add item window
 */
function createAddWindow() {
  if (addWindow) {
    addWindow.focus();
    return;
  }

  addWindow = new BrowserWindow({
    width: 400,
    height: 350,
    title: 'Add Schedule Item',
    parent: mainWindow || scheduleWindow,
    modal: true,
    resizable: false,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  addWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'addWindow.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  // Remove menu bar from modal window
  addWindow.setMenuBarVisibility(false);

  addWindow.on('closed', () => {
    addWindow = null;
  });
}

/**
 * Create the calendar window
 */
function createCalendarWindow() {
  if (calendarWindow) {
    calendarWindow.focus();
    return;
  }

  calendarWindow = new BrowserWindow({
    width: 900,
    height: 950,
    title: 'Calendar View',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  calendarWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'calendar', 'Calendar.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  calendarWindow.on('closed', () => {
    calendarWindow = null;
  });
}

/**
 * Create the rooms management window
 */
function createRoomsWindow() {
  const roomsWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    title: 'Room Management',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  roomsWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'rooms.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  if (isDev) {
    roomsWindow.webContents.openDevTools();
  }
}

/**
 * Create the bookings window
 */
function createBookingsWindow() {
  const bookingsWindow = new BrowserWindow({
    width: 1400,
    height: 900,
    title: 'Room Bookings',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    },
  });

  bookingsWindow.loadURL(
    url.format({
      pathname: path.join(__dirname, 'bookings.html'),
      protocol: 'file:',
      slashes: true,
    })
  );

  if (isDev) {
    bookingsWindow.webContents.openDevTools();
  }
}

// ========== IPC Handlers ==========

/**
 * Handle add item request
 */
ipcMain.on('item:add', (event, item) => {
  if (!item || typeof item !== 'string' || item.trim() === '') {
    console.warn('Invalid item received:', item);
    return;
  }

  try {
    // Add to data store
    dataStore.addName(item.trim());

    // Notify all windows
    const windows = [mainWindow, scheduleWindow];
    windows.forEach(win => {
      if (win && !win.isDestroyed()) {
        win.webContents.send('item:add', item);
      }
    });

    // Close add window
    if (addWindow && !addWindow.isDestroyed()) {
      addWindow.close();
    }
  } catch (error) {
    console.error('Error adding item:', error);
    dialog.showErrorBox('Error', 'Failed to add item: ' + error.message);
  }
});

/**
 * Handle clear items request
 */
ipcMain.on('item:clear', () => {
  try {
    dataStore.clearNames();
    
    const windows = [mainWindow, scheduleWindow];
    windows.forEach(win => {
      if (win && !win.isDestroyed()) {
        win.webContents.send('item:clear');
      }
    });
  } catch (error) {
    console.error('Error clearing items:', error);
  }
});

/**
 * Handle window open requests
 */
ipcMain.on('open-schedule', () => createScheduleWindow());
ipcMain.on('open-calendar', () => createCalendarWindow());
ipcMain.on('open-time-sorter', () => {
  // TODO: Implement time sorter window
  console.log('Time sorter requested');
});
ipcMain.on('open-rooms', () => createRoomsWindow());
ipcMain.on('open-bookings', () => createBookingsWindow());

// ========== Room IPC Handlers ==========

/**
 * Get all rooms
 */
ipcMain.handle('rooms:get', async () => {
  try {
    return dataStore.getRooms();
  } catch (error) {
    console.error('Error getting rooms:', error);
    throw error;
  }
});

/**
 * Add a new room
 */
ipcMain.handle('rooms:add', async (event, room) => {
  try {
    dataStore.addRoom(room);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('rooms:updated', dataStore.getRooms());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error adding room:', error);
    throw error;
  }
});

/**
 * Update a room
 */
ipcMain.handle('rooms:update', async (event, id, updates) => {
  try {
    dataStore.updateRoom(id, updates);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('rooms:updated', dataStore.getRooms());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error updating room:', error);
    throw error;
  }
});

/**
 * Delete a room
 */
ipcMain.handle('rooms:delete', async (event, id) => {
  try {
    dataStore.deleteRoom(id);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('rooms:updated', dataStore.getRooms());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error deleting room:', error);
    throw error;
  }
});

/**
 * Get room by ID
 */
ipcMain.handle('rooms:getById', async (event, id) => {
  try {
    return dataStore.getRoomById(id);
  } catch (error) {
    console.error('Error getting room by ID:', error);
    throw error;
  }
});

// ========== Booking IPC Handlers ==========

/**
 * Get all bookings
 */
ipcMain.handle('bookings:get', async () => {
  try {
    return dataStore.getBookings();
  } catch (error) {
    console.error('Error getting bookings:', error);
    throw error;
  }
});

/**
 * Add a new booking
 */
ipcMain.handle('bookings:add', async (event, booking) => {
  try {
    // Check availability first
    const available = dataStore.isRoomAvailable(
      booking.roomId,
      booking.startTime,
      booking.endTime
    );
    
    if (!available) {
      throw new Error('Room is not available for the selected time slot');
    }
    
    dataStore.addBooking(booking);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('bookings:updated', dataStore.getBookings());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error adding booking:', error);
    throw error;
  }
});

/**
 * Update a booking
 */
ipcMain.handle('bookings:update', async (event, id, updates) => {
  try {
    // If updating times, check availability
    if (updates.startTime || updates.endTime) {
      const booking = dataStore.getBookingById(id);
      if (!booking) {
        throw new Error('Booking not found');
      }
      
      const startTime = updates.startTime || booking.startTime;
      const endTime = updates.endTime || booking.endTime;
      
      // Check availability (excluding current booking)
      const bookings = dataStore.getBookingsByRoom(booking.roomId);
      const conflicts = bookings.filter(b => {
        if (b.id === id) return false; // Exclude current booking
        
        const start = new Date(startTime);
        const end = new Date(endTime);
        const bStart = new Date(b.startTime);
        const bEnd = new Date(b.endTime);
        
        return start < bEnd && end > bStart;
      });
      
      if (conflicts.length > 0) {
        throw new Error('Time slot conflicts with another booking');
      }
    }
    
    dataStore.updateBooking(id, updates);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('bookings:updated', dataStore.getBookings());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error updating booking:', error);
    throw error;
  }
});

/**
 * Delete a booking
 */
ipcMain.handle('bookings:delete', async (event, id) => {
  try {
    dataStore.deleteBooking(id);
    
    // Notify all windows of update
    BrowserWindow.getAllWindows().forEach(win => {
      if (!win.isDestroyed()) {
        win.webContents.send('bookings:updated', dataStore.getBookings());
      }
    });
    
    return { success: true };
  } catch (error) {
    console.error('Error deleting booking:', error);
    throw error;
  }
});

/**
 * Get booking by ID
 */
ipcMain.handle('bookings:getById', async (event, id) => {
  try {
    return dataStore.getBookingById(id);
  } catch (error) {
    console.error('Error getting booking by ID:', error);
    throw error;
  }
});

/**
 * Get bookings by room
 */
ipcMain.handle('bookings:getByRoom', async (event, roomId) => {
  try {
    return dataStore.getBookingsByRoom(roomId);
  } catch (error) {
    console.error('Error getting bookings by room:', error);
    throw error;
  }
});

/**
 * Check room availability
 */
ipcMain.handle('bookings:checkAvailability', async (event, roomId, startTime, endTime, excludeBookingId) => {
  try {
    const bookings = dataStore.getBookingsByRoom(roomId);
    
    // Check for conflicts
    const conflicts = bookings.filter(booking => {
      if (excludeBookingId && booking.id === excludeBookingId) {
        return false; // Exclude the booking being edited
      }
      
      const start = new Date(startTime);
      const end = new Date(endTime);
      const bookingStart = new Date(booking.startTime);
      const bookingEnd = new Date(booking.endTime);
      
      // Check for overlap
      return start < bookingEnd && end > bookingStart;
    });
    
    return conflicts.length === 0;
  } catch (error) {
    console.error('Error checking availability:', error);
    throw error;
  }
});

// ========== Menu Setup ==========

/**
 * Build and set application menu
 */
function setupMenu() {
  const menuTemplate = buildMenuTemplate({
    onAddItem: () => createAddWindow(),
    onClearItems: () => {
      if (scheduleWindow && !scheduleWindow.isDestroyed()) {
        scheduleWindow.webContents.send('item:clear');
      }
    },
    onOpenSchedule: () => createScheduleWindow(),
    onOpenCalendar: () => createCalendarWindow(),
    onOpenTimeSorter: () => {
      console.log('Time sorter not yet implemented');
    },
  });

  // Add developer menu in development mode
  if (isDev) {
    menuTemplate.push(buildDeveloperMenu());
  }

  const menu = Menu.buildFromTemplate(menuTemplate);
  Menu.setApplicationMenu(menu);
}

// ========== App Lifecycle ==========

/**
 * App ready handler
 */
app.whenReady().then(() => {
  createMainWindow();
  setupMenu();

  // On macOS, re-create window when dock icon is clicked
  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createMainWindow();
    }
  });
});

/**
 * Quit when all windows are closed (except on macOS)
 */
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

/**
 * Before quit - cleanup
 */
app.on('before-quit', () => {
  // Perform any cleanup here
  console.log('Application closing...');
});

/**
 * Handle uncaught exceptions
 */
process.on('uncaughtException', (error) => {
  console.error('Uncaught exception:', error);
  
  dialog.showErrorBox(
    'Application Error',
    'An unexpected error occurred. The application may need to restart.\n\n' + error.message
  );
});

// ========== Security ==========

/**
 * Disable navigation to external URLs
 */
app.on('web-contents-created', (event, contents) => {
  contents.on('will-navigate', (event, navigationUrl) => {
    const parsedUrl = new URL(navigationUrl);
    
    // Only allow file:// protocol
    if (parsedUrl.protocol !== 'file:') {
      event.preventDefault();
      console.warn('Blocked navigation to:', navigationUrl);
    }
  });

  // Prevent new window creation
  contents.setWindowOpenHandler(({ url }) => {
    console.warn('Blocked window open:', url);
    return { action: 'deny' };
  });
});

// Export for testing
module.exports = {
  createMainWindow,
  createScheduleWindow,
  createAddWindow,
  createCalendarWindow,
};
